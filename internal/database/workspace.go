package database

import (
	"fmt"
	"time"

	"github.com/google/uuid"
)

type Workspace struct {
	ID          uuid.UUID `json:"id"`
	Name        string    `json:"name"`
	Slug        string    `json:"slug"`
	Description string    `json:"description"`
	Plan        string    `json:"plan"`
	Settings    string    `json:"settings"` // JSON string
	IsActive    bool      `json:"is_active"`
	CreatedAt   time.Time `json:"created_at"`
	UpdatedAt   time.Time `json:"updated_at"`
}

type WorkspaceMembership struct {
	ID          uuid.UUID `json:"id"`
	WorkspaceID uuid.UUID `json:"workspace_id"`
	UserID      int       `json:"user_id"`
	Role        string    `json:"role"`        // owner, admin, member, viewer
	Status      string    `json:"status"`      // active, suspended, invited
	InvitedBy   *int      `json:"invited_by"`  // nullable
	InvitedAt   *time.Time `json:"invited_at"` // nullable
	JoinedAt    time.Time `json:"joined_at"`
	CreatedAt   time.Time `json:"created_at"`
}

type UserWorkspace struct {
	UserID           int       `json:"user_id"`
	Email            string    `json:"email"`
	UserName         string    `json:"user_name"`
	WorkspaceID      uuid.UUID `json:"workspace_id"`
	WorkspaceName    string    `json:"workspace_name"`
	WorkspaceSlug    string    `json:"workspace_slug"`
	Role             string    `json:"role"`
	MembershipStatus string    `json:"membership_status"`
	JoinedAt         time.Time `json:"joined_at"`
	Plan             string    `json:"plan"`
	WorkspaceActive  bool      `json:"workspace_active"`
}

// CreateWorkspaceForUser creates a new workspace and makes the user an owner
func (s *service) CreateWorkspaceForUser(userID int, workspaceName string) (*Workspace, error) {
	tx, err := s.db.Begin()
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()

	// Create the workspace (slug will be auto-generated by trigger)
	workspace := &Workspace{}
	workspaceQuery := `
		INSERT INTO workspaces (name, description, plan, is_active, created_at, updated_at)
		VALUES ($1, $2, 'free', true, NOW(), NOW())
		RETURNING id, name, slug, description, plan, settings, is_active, created_at, updated_at`

	err = tx.QueryRow(workspaceQuery, workspaceName, "Personal workspace").Scan(
		&workspace.ID, &workspace.Name, &workspace.Slug, &workspace.Description,
		&workspace.Plan, &workspace.Settings, &workspace.IsActive,
		&workspace.CreatedAt, &workspace.UpdatedAt,
	)
	if err != nil {
		return nil, err
	}

	// Add the user as an owner of the workspace
	membershipQuery := `
		INSERT INTO workspace_memberships (workspace_id, user_id, role, status, joined_at, created_at)
		VALUES ($1, $2, 'owner', 'active', NOW(), NOW())`

	_, err = tx.Exec(membershipQuery, workspace.ID, userID)
	if err != nil {
		return nil, err
	}

	if err = tx.Commit(); err != nil {
		return nil, err
	}

	return workspace, nil
}

// GetUserWorkspaces retrieves all workspaces for a user
func (s *service) GetUserWorkspaces(userID int) ([]UserWorkspace, error) {
	query := `
		SELECT 
			user_id, email, user_name, workspace_id, workspace_name, 
			workspace_slug, role, membership_status, joined_at, plan, workspace_active
		FROM user_workspaces 
		WHERE user_id = $1
		ORDER BY joined_at ASC`

	rows, err := s.db.Query(query, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var workspaces []UserWorkspace
	for rows.Next() {
		var uw UserWorkspace
		err := rows.Scan(
			&uw.UserID, &uw.Email, &uw.UserName, &uw.WorkspaceID,
			&uw.WorkspaceName, &uw.WorkspaceSlug, &uw.Role,
			&uw.MembershipStatus, &uw.JoinedAt, &uw.Plan, &uw.WorkspaceActive,
		)
		if err != nil {
			return nil, err
		}
		workspaces = append(workspaces, uw)
	}

	return workspaces, nil
}

// GetWorkspaceBySlug retrieves a workspace by its slug
func (s *service) GetWorkspaceBySlug(slug string) (*Workspace, error) {
	workspace := &Workspace{}
	query := `
		SELECT id, name, slug, description, plan, settings, is_active, created_at, updated_at
		FROM workspaces 
		WHERE slug = $1 AND is_active = true`

	err := s.db.QueryRow(query, slug).Scan(
		&workspace.ID, &workspace.Name, &workspace.Slug, &workspace.Description,
		&workspace.Plan, &workspace.Settings, &workspace.IsActive,
		&workspace.CreatedAt, &workspace.UpdatedAt,
	)

	if err != nil {
		return nil, err
	}

	return workspace, nil
}

// CheckUserWorkspaceAccess checks if a user has access to a workspace
func (s *service) CheckUserWorkspaceAccess(userID int, workspaceSlug string) (*UserWorkspace, error) {
	var uw UserWorkspace
	query := `
		SELECT 
			user_id, email, user_name, workspace_id, workspace_name, 
			workspace_slug, role, membership_status, joined_at, plan, workspace_active
		FROM user_workspaces 
		WHERE user_id = $1 AND workspace_slug = $2`

	err := s.db.QueryRow(query, userID, workspaceSlug).Scan(
		&uw.UserID, &uw.Email, &uw.UserName, &uw.WorkspaceID,
		&uw.WorkspaceName, &uw.WorkspaceSlug, &uw.Role,
		&uw.MembershipStatus, &uw.JoinedAt, &uw.Plan, &uw.WorkspaceActive,
	)

	if err != nil {
		return nil, err
	}

	return &uw, nil
}

// InviteUserToWorkspace creates a pending invitation for a user to join a workspace
func (s *service) InviteUserToWorkspace(workspaceID uuid.UUID, invitedEmail string, inviterUserID int, role string) error {
	// First check if user exists
	invitedUser, err := s.GetUserByEmail(invitedEmail)
	if err != nil {
		// User doesn't exist - in a real app, you might want to create a pending invitation
		// For now, we'll return an error
		return fmt.Errorf("user with email %s not found", invitedEmail)
	}

	// Check if user is already a member
	existingQuery := `
		SELECT id FROM workspace_memberships 
		WHERE workspace_id = $1 AND user_id = $2`
	
	var existingID uuid.UUID
	err = s.db.QueryRow(existingQuery, workspaceID, invitedUser.ID).Scan(&existingID)
	if err == nil {
		return fmt.Errorf("user is already a member of this workspace")
	}

	// Create the invitation
	inviteQuery := `
		INSERT INTO workspace_memberships (workspace_id, user_id, role, status, invited_by, invited_at, created_at)
		VALUES ($1, $2, $3, 'invited', $4, NOW(), NOW())`

	_, err = s.db.Exec(inviteQuery, workspaceID, invitedUser.ID, role, inviterUserID)
	return err
}

// AcceptWorkspaceInvitation accepts a pending workspace invitation
func (s *service) AcceptWorkspaceInvitation(userID int, workspaceID uuid.UUID) error {
	query := `
		UPDATE workspace_memberships 
		SET status = 'active', joined_at = NOW()
		WHERE workspace_id = $1 AND user_id = $2 AND status = 'invited'`

	result, err := s.db.Exec(query, workspaceID, userID)
	if err != nil {
		return err
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return err
	}

	if rowsAffected == 0 {
		return fmt.Errorf("no pending invitation found")
	}

	return nil
}