package database

import (
	"fmt"
	"time"

	"github.com/google/uuid"
)

type Workspace struct {
	ID          uuid.UUID `json:"id"`
	Name        string    `json:"name"`
	Slug        string    `json:"slug"`
	Description string    `json:"description"`
	Plan        string    `json:"plan"`
	Settings    string    `json:"settings"` // JSON string
	IsActive    bool      `json:"is_active"`
	CreatedAt   time.Time `json:"created_at"`
	UpdatedAt   time.Time `json:"updated_at"`
}

type WorkspaceMembership struct {
	ID          uuid.UUID `json:"id"`
	WorkspaceID uuid.UUID `json:"workspace_id"`
	UserID      int       `json:"user_id"`
	Role        string    `json:"role"`        // owner, admin, member, viewer
	Status      string    `json:"status"`      // active, suspended, invited
	InvitedBy   *int      `json:"invited_by"`  // nullable
	InvitedAt   *time.Time `json:"invited_at"` // nullable
	JoinedAt    time.Time `json:"joined_at"`
	CreatedAt   time.Time `json:"created_at"`
}

type UserWorkspace struct {
	UserID           int       `json:"user_id"`
	Email            string    `json:"email"`
	UserName         string    `json:"user_name"`
	WorkspaceID      uuid.UUID `json:"workspace_id"`
	WorkspaceName    string    `json:"workspace_name"`
	WorkspaceSlug    string    `json:"workspace_slug"`
	Role             string    `json:"role"`
	MembershipStatus string    `json:"membership_status"`
	JoinedAt         time.Time `json:"joined_at"`
	Plan             string    `json:"plan"`
	WorkspaceActive  bool      `json:"workspace_active"`
}

type WorkspaceMember struct {
	ID        int       `json:"id"`
	Email     string    `json:"email"`
	Name      string    `json:"name"`
	AvatarURL string    `json:"avatar_url"`
	Role      string    `json:"role"`
	Status    string    `json:"status"`
	JoinedAt  time.Time `json:"joined_at"`
}

type WorkspaceInvitation struct {
	ID            uuid.UUID  `json:"id"`
	WorkspaceID   uuid.UUID  `json:"workspace_id"`
	InviterID     int        `json:"inviter_id"`
	InviterName   string     `json:"inviter_name"`
	InviteeEmail  string     `json:"invitee_email"`
	InviteeID     *int       `json:"invitee_id"`
	Role          string     `json:"role"`
	Status        string     `json:"status"`
	Token         string     `json:"token"`
	ExpiresAt     time.Time  `json:"expires_at"`
	CreatedAt     time.Time  `json:"created_at"`
}

// CreateWorkspaceForUser creates a new workspace and makes the user an owner
func (s *service) CreateWorkspaceForUser(userID int, workspaceName string) (*Workspace, error) {
	tx, err := s.db.Begin()
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()

	// Create the workspace (slug will be auto-generated by trigger)
	workspace := &Workspace{}
	workspaceQuery := `
		INSERT INTO workspaces (name, description, plan, is_active, created_at, updated_at)
		VALUES ($1, $2, 'free', true, NOW(), NOW())
		RETURNING id, name, slug, description, plan, settings, is_active, created_at, updated_at`

	err = tx.QueryRow(workspaceQuery, workspaceName, "Personal workspace").Scan(
		&workspace.ID, &workspace.Name, &workspace.Slug, &workspace.Description,
		&workspace.Plan, &workspace.Settings, &workspace.IsActive,
		&workspace.CreatedAt, &workspace.UpdatedAt,
	)
	if err != nil {
		return nil, err
	}

	// Add the user as an owner of the workspace
	membershipQuery := `
		INSERT INTO workspace_memberships (workspace_id, user_id, role, status, joined_at, created_at)
		VALUES ($1, $2, 'owner', 'active', NOW(), NOW())`

	_, err = tx.Exec(membershipQuery, workspace.ID, userID)
	if err != nil {
		return nil, err
	}

	if err = tx.Commit(); err != nil {
		return nil, err
	}

	return workspace, nil
}

// GetUserWorkspaces retrieves all workspaces for a user
func (s *service) GetUserWorkspaces(userID int) ([]UserWorkspace, error) {
	query := `
		SELECT 
			user_id, email, user_name, workspace_id, workspace_name, 
			workspace_slug, role, membership_status, joined_at, plan, workspace_active
		FROM user_workspaces 
		WHERE user_id = $1
		ORDER BY joined_at ASC`

	rows, err := s.db.Query(query, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var workspaces []UserWorkspace
	for rows.Next() {
		var uw UserWorkspace
		err := rows.Scan(
			&uw.UserID, &uw.Email, &uw.UserName, &uw.WorkspaceID,
			&uw.WorkspaceName, &uw.WorkspaceSlug, &uw.Role,
			&uw.MembershipStatus, &uw.JoinedAt, &uw.Plan, &uw.WorkspaceActive,
		)
		if err != nil {
			return nil, err
		}
		workspaces = append(workspaces, uw)
	}

	return workspaces, nil
}

// GetWorkspaceBySlug retrieves a workspace by its slug
func (s *service) GetWorkspaceBySlug(slug string) (*Workspace, error) {
	workspace := &Workspace{}
	query := `
		SELECT id, name, slug, description, plan, settings, is_active, created_at, updated_at
		FROM workspaces 
		WHERE slug = $1 AND is_active = true`

	err := s.db.QueryRow(query, slug).Scan(
		&workspace.ID, &workspace.Name, &workspace.Slug, &workspace.Description,
		&workspace.Plan, &workspace.Settings, &workspace.IsActive,
		&workspace.CreatedAt, &workspace.UpdatedAt,
	)

	if err != nil {
		return nil, err
	}

	return workspace, nil
}

// CheckUserWorkspaceAccess checks if a user has access to a workspace
func (s *service) CheckUserWorkspaceAccess(userID int, workspaceSlug string) (*UserWorkspace, error) {
	var uw UserWorkspace
	query := `
		SELECT 
			user_id, email, user_name, workspace_id, workspace_name, 
			workspace_slug, role, membership_status, joined_at, plan, workspace_active
		FROM user_workspaces 
		WHERE user_id = $1 AND workspace_slug = $2`

	err := s.db.QueryRow(query, userID, workspaceSlug).Scan(
		&uw.UserID, &uw.Email, &uw.UserName, &uw.WorkspaceID,
		&uw.WorkspaceName, &uw.WorkspaceSlug, &uw.Role,
		&uw.MembershipStatus, &uw.JoinedAt, &uw.Plan, &uw.WorkspaceActive,
	)

	if err != nil {
		return nil, err
	}

	return &uw, nil
}

// InviteUserToWorkspace creates a pending invitation for a user to join a workspace
// InviteUserToWorkspace creates a new workspace invitation
func (s *service) InviteUserToWorkspace(workspaceID uuid.UUID, invitedEmail string, inviterUserID int, role string) error {
	// Check if user exists (but don't require it)
	var invitedUserID *int
	invitedUser, err := s.GetUserByEmail(invitedEmail)
	if err == nil {
		invitedUserID = &invitedUser.ID
		
		// Check if user is already a member
		existingQuery := `
			SELECT id FROM workspace_memberships 
			WHERE workspace_id = $1 AND user_id = $2 AND status = 'active'`
		
		var existingID uuid.UUID
		err = s.db.QueryRow(existingQuery, workspaceID, invitedUser.ID).Scan(&existingID)
		if err == nil {
			return fmt.Errorf("user is already a member of this workspace")
		}
	}

	// Check if there's already a pending invitation
	existingInviteQuery := `
		SELECT id FROM workspace_invitations 
		WHERE workspace_id = $1 AND invitee_email = $2 AND status = 'pending'`
	
	var existingInviteID uuid.UUID
	err = s.db.QueryRow(existingInviteQuery, workspaceID, invitedEmail).Scan(&existingInviteID)
	if err == nil {
		return fmt.Errorf("invitation already sent to this email")
	}

	// Create the invitation (token will be auto-generated by trigger)
	inviteQuery := `
		INSERT INTO workspace_invitations (workspace_id, inviter_id, invitee_email, invitee_id, role)
		VALUES ($1, $2, $3, $4, $5)
		RETURNING id, token`

	var invitationID uuid.UUID
	var token string
	err = s.db.QueryRow(inviteQuery, workspaceID, inviterUserID, invitedEmail, invitedUserID, role).Scan(&invitationID, &token)
	if err != nil {
		return fmt.Errorf("failed to create invitation: %w", err)
	}

	// Create notification if user exists
	if invitedUserID != nil {
		notification := &Notification{
			UserID:  *invitedUserID,
			Type:    "workspace_invitation",
			Title:   "Workspace Invitation",
			Message: fmt.Sprintf("You've been invited to join a workspace"),
			Data:    fmt.Sprintf(`{"invitation_id": "%s", "token": "%s"}`, invitationID, token),
		}
		// Note: We could ignore notification creation errors to not block invitation
		s.CreateNotification(notification)
	}

	return nil
}

// AcceptWorkspaceInvitation accepts a pending workspace invitation using token
func (s *service) AcceptWorkspaceInvitationByToken(token string, userID int) error {
	// First, get the invitation details
	invitation, err := s.GetPendingInvitationByToken(token)
	if err != nil {
		return fmt.Errorf("invalid or expired invitation: %w", err)
	}

	// Check if the invitation is for this user (if invitee_id is set)
	if invitation.InviteeID != nil && *invitation.InviteeID != userID {
		return fmt.Errorf("invitation is not for this user")
	}

	// Start a transaction to ensure atomicity
	tx, err := s.db.Begin()
	if err != nil {
		return fmt.Errorf("failed to start transaction: %w", err)
	}
	defer tx.Rollback()

	// Update invitation status
	updateInviteQuery := `
		UPDATE workspace_invitations 
		SET status = 'accepted', updated_at = NOW(), invitee_id = $1
		WHERE token = $2 AND status = 'pending'`

	result, err := tx.Exec(updateInviteQuery, userID, token)
	if err != nil {
		return fmt.Errorf("failed to update invitation: %w", err)
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("failed to get rows affected: %w", err)
	}

	if rowsAffected == 0 {
		return fmt.Errorf("invitation not found or already processed")
	}

	// Create workspace membership
	membershipQuery := `
		INSERT INTO workspace_memberships (workspace_id, user_id, role, status, invited_by, invited_at, joined_at)
		VALUES ($1, $2, $3, 'active', $4, $5, NOW())`

	_, err = tx.Exec(membershipQuery, invitation.WorkspaceID, userID, invitation.Role, invitation.InviterID, invitation.CreatedAt)
	if err != nil {
		return fmt.Errorf("failed to create membership: %w", err)
	}

	// Create notification for inviter
	inviterNotification := &Notification{
		UserID:  invitation.InviterID,
		Type:    "invitation_accepted",
		Title:   "Invitation Accepted",
		Message: fmt.Sprintf("Your invitation to %s was accepted", invitation.WorkspaceName),
		Data:    fmt.Sprintf(`{"workspace_id": "%s", "accepted_by": %d}`, invitation.WorkspaceID, userID),
	}

	// Insert notification within transaction
	notificationQuery := `
		INSERT INTO notifications (user_id, type, title, message, data)
		VALUES ($1, $2, $3, $4, $5)`
	
	_, err = tx.Exec(notificationQuery, inviterNotification.UserID, inviterNotification.Type, 
		inviterNotification.Title, inviterNotification.Message, inviterNotification.Data)
	if err != nil {
		// Don't fail the whole operation for notification errors
		// Just log it (you might want to add logging here)
	}

	// Commit transaction
	return tx.Commit()
}

// DeclineWorkspaceInvitation declines a pending workspace invitation
func (s *service) DeclineWorkspaceInvitation(token string, userID int) error {
	// Get invitation details first
	invitation, err := s.GetPendingInvitationByToken(token)
	if err != nil {
		return fmt.Errorf("invalid or expired invitation: %w", err)
	}

	// Check if the invitation is for this user (if invitee_id is set)
	if invitation.InviteeID != nil && *invitation.InviteeID != userID {
		return fmt.Errorf("invitation is not for this user")
	}

	// Update invitation status
	query := `
		UPDATE workspace_invitations 
		SET status = 'declined', updated_at = NOW(), invitee_id = $1
		WHERE token = $2 AND status = 'pending'`

	result, err := s.db.Exec(query, userID, token)
	if err != nil {
		return fmt.Errorf("failed to decline invitation: %w", err)
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("failed to get rows affected: %w", err)
	}

	if rowsAffected == 0 {
		return fmt.Errorf("invitation not found or already processed")
	}

	// Create notification for inviter
	notification := &Notification{
		UserID:  invitation.InviterID,
		Type:    "invitation_declined",
		Title:   "Invitation Declined",
		Message: fmt.Sprintf("Your invitation to %s was declined", invitation.WorkspaceName),
		Data:    fmt.Sprintf(`{"workspace_id": "%s", "declined_by": %d}`, invitation.WorkspaceID, userID),
	}

	// Create notification (ignore errors to not block the main operation)
	s.CreateNotification(notification)

	return nil
}

// Add these methods to your database/workspace.go file

// UpdateWorkspace updates workspace details (name, description, settings)
func (s *service) UpdateWorkspace(workspaceID uuid.UUID, name, description, settings string, userID int) error {
	// First check if user has permission (owner or admin)
	permissionQuery := `
		SELECT role FROM workspace_memberships 
		WHERE workspace_id = $1 AND user_id = $2 AND status = 'active'`
	
	var role string
	err := s.db.QueryRow(permissionQuery, workspaceID, userID).Scan(&role)
	if err != nil {
		return fmt.Errorf("user does not have access to this workspace")
	}
	
	if role != "owner" && role != "admin" {
		return fmt.Errorf("insufficient permissions to update workspace")
	}

	// Update the workspace
	updateQuery := `
		UPDATE workspaces 
		SET name = $1, description = $2, settings = $3, updated_at = NOW()
		WHERE id = $4`
	
	result, err := s.db.Exec(updateQuery, name, description, settings, workspaceID)
	if err != nil {
		return fmt.Errorf("failed to update workspace: %w", err)
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("failed to get rows affected: %w", err)
	}

	if rowsAffected == 0 {
		return fmt.Errorf("workspace not found")
	}

	return nil
}

// GetWorkspaceMembers returns all members of a workspace
func (s *service) GetWorkspaceMembers(workspaceID uuid.UUID, userID int) ([]WorkspaceMember, error) {
	// First check if user has access to this workspace
	accessQuery := `
		SELECT role FROM workspace_memberships 
		WHERE workspace_id = $1 AND user_id = $2 AND status = 'active'`
	
	var userRole string
	err := s.db.QueryRow(accessQuery, workspaceID, userID).Scan(&userRole)
	if err != nil {
		return nil, fmt.Errorf("user does not have access to this workspace")
	}

	// Get all members
	membersQuery := `
		SELECT u.id, u.email, u.name, u.avatar_url, wm.role, wm.status, wm.joined_at
		FROM users u
		JOIN workspace_memberships wm ON u.id = wm.user_id
		WHERE wm.workspace_id = $1 AND wm.status = 'active'
		ORDER BY 
			CASE wm.role 
				WHEN 'owner' THEN 1 
				WHEN 'admin' THEN 2 
				WHEN 'member' THEN 3 
				WHEN 'viewer' THEN 4 
				ELSE 5 
			END,
			wm.joined_at ASC`

	rows, err := s.db.Query(membersQuery, workspaceID)
	if err != nil {
		return nil, fmt.Errorf("failed to get workspace members: %w", err)
	}
	defer rows.Close()

	var members []WorkspaceMember
	for rows.Next() {
		var member WorkspaceMember
		err := rows.Scan(
			&member.ID, &member.Email, &member.Name, &member.AvatarURL,
			&member.Role, &member.Status, &member.JoinedAt,
		)
		if err != nil {
			return nil, fmt.Errorf("failed to scan member: %w", err)
		}
		members = append(members, member)
	}

	return members, nil
}

// GetWorkspacePendingInvitations returns all pending invitations for a workspace
func (s *service) GetWorkspacePendingInvitations(workspaceID uuid.UUID, userID int) ([]WorkspaceInvitation, error) {
	// First check if user has permission (owner or admin)
	permissionQuery := `
		SELECT role FROM workspace_memberships 
		WHERE workspace_id = $1 AND user_id = $2 AND status = 'active'`
	
	var role string
	err := s.db.QueryRow(permissionQuery, workspaceID, userID).Scan(&role)
	if err != nil {
		return nil, fmt.Errorf("user does not have access to this workspace")
	}
	
	if role != "owner" && role != "admin" {
		return nil, fmt.Errorf("insufficient permissions to view pending invitations")
	}

	// Get pending invitations
	invitationsQuery := `
		SELECT wi.id, wi.workspace_id, wi.inviter_id, u.name as inviter_name, 
			   wi.invitee_email, wi.invitee_id, wi.role, wi.status, wi.token, 
			   wi.expires_at, wi.created_at
		FROM workspace_invitations wi
		JOIN users u ON wi.inviter_id = u.id
		WHERE wi.workspace_id = $1 AND wi.status = 'pending'
		ORDER BY wi.created_at DESC`

	rows, err := s.db.Query(invitationsQuery, workspaceID)
	if err != nil {
		return nil, fmt.Errorf("failed to get pending invitations: %w", err)
	}
	defer rows.Close()

	var invitations []WorkspaceInvitation
	for rows.Next() {
		var invitation WorkspaceInvitation
		err := rows.Scan(
			&invitation.ID, &invitation.WorkspaceID, &invitation.InviterID,
			&invitation.InviterName, &invitation.InviteeEmail, &invitation.InviteeID,
			&invitation.Role, &invitation.Status, &invitation.Token,
			&invitation.ExpiresAt, &invitation.CreatedAt,
		)
		if err != nil {
			return nil, fmt.Errorf("failed to scan invitation: %w", err)
		}
		invitations = append(invitations, invitation)
	}

	return invitations, nil
}

// UpdateMemberRole updates a member's role in a workspace
func (s *service) UpdateMemberRole(workspaceID uuid.UUID, memberUserID int, newRole string, updaterUserID int) error {
	// Check if updater has permission (owner or admin)
	permissionQuery := `
		SELECT role FROM workspace_memberships 
		WHERE workspace_id = $1 AND user_id = $2 AND status = 'active'`
	
	var updaterRole string
	err := s.db.QueryRow(permissionQuery, workspaceID, updaterUserID).Scan(&updaterRole)
	if err != nil {
		return fmt.Errorf("user does not have access to this workspace")
	}
	
	if updaterRole != "owner" && updaterRole != "admin" {
		return fmt.Errorf("insufficient permissions to update member roles")
	}

	// Get member's current role
	var currentRole string
	err = s.db.QueryRow(permissionQuery, workspaceID, memberUserID).Scan(&currentRole)
	if err != nil {
		return fmt.Errorf("member not found in workspace")
	}

	// Only owners can change other owners or promote to owner
	if (currentRole == "owner" || newRole == "owner") && updaterRole != "owner" {
		return fmt.Errorf("only workspace owners can manage owner roles")
	}

	// Validate new role
	validRoles := map[string]bool{"owner": true, "admin": true, "member": true, "viewer": true}
	if !validRoles[newRole] {
		return fmt.Errorf("invalid role")
	}

	// Update member role
	updateQuery := `
		UPDATE workspace_memberships 
		SET role = $1 
		WHERE workspace_id = $2 AND user_id = $3`
	
	result, err := s.db.Exec(updateQuery, newRole, workspaceID, memberUserID)
	if err != nil {
		return fmt.Errorf("failed to update member role: %w", err)
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("failed to get rows affected: %w", err)
	}

	if rowsAffected == 0 {
		return fmt.Errorf("member not found")
	}

	return nil
}

// RemoveMemberFromWorkspace removes a member from a workspace
func (s *service) RemoveMemberFromWorkspace(workspaceID uuid.UUID, memberUserID int, removerUserID int) error {
	// Check if remover has permission (owner or admin)
	permissionQuery := `
		SELECT role FROM workspace_memberships 
		WHERE workspace_id = $1 AND user_id = $2 AND status = 'active'`
	
	var removerRole string
	err := s.db.QueryRow(permissionQuery, workspaceID, removerUserID).Scan(&removerRole)
	if err != nil {
		return fmt.Errorf("user does not have access to this workspace")
	}
	
	if removerRole != "owner" && removerRole != "admin" {
		return fmt.Errorf("insufficient permissions to remove members")
	}

	// Get member's current role
	var memberRole string
	err = s.db.QueryRow(permissionQuery, workspaceID, memberUserID).Scan(&memberRole)
	if err != nil {
		return fmt.Errorf("member not found in workspace")
	}

	// Only owners can remove other owners
	if memberRole == "owner" && removerRole != "owner" {
		return fmt.Errorf("only workspace owners can remove other owners")
	}

	// Don't allow removing yourself if you're the only owner
	if memberUserID == removerUserID && memberRole == "owner" {
		var ownerCount int
		countQuery := `
			SELECT COUNT(*) FROM workspace_memberships 
			WHERE workspace_id = $1 AND role = 'owner' AND status = 'active'`
		
		err = s.db.QueryRow(countQuery, workspaceID).Scan(&ownerCount)
		if err != nil {
			return fmt.Errorf("failed to check owner count: %w", err)
		}
		
		if ownerCount <= 1 {
			return fmt.Errorf("cannot remove the last owner from workspace")
		}
	}

	// Remove member
	removeQuery := `
		UPDATE workspace_memberships 
		SET status = 'removed' 
		WHERE workspace_id = $1 AND user_id = $2`
	
	result, err := s.db.Exec(removeQuery, workspaceID, memberUserID)
	if err != nil {
		return fmt.Errorf("failed to remove member: %w", err)
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("failed to get rows affected: %w", err)
	}

	if rowsAffected == 0 {
		return fmt.Errorf("member not found")
	}

	return nil
}

// CancelWorkspaceInvitation cancels a pending workspace invitation
func (s *service) CancelWorkspaceInvitation(invitationID uuid.UUID, userID int) error {
	// Get invitation details and check permissions
	checkQuery := `
		SELECT wi.workspace_id, wi.inviter_id, wm.role
		FROM workspace_invitations wi
		JOIN workspace_memberships wm ON wi.workspace_id = wm.workspace_id
		WHERE wi.id = $1 AND wm.user_id = $2 AND wm.status = 'active' AND wi.status = 'pending'`
	
	var workspaceID uuid.UUID
	var inviterID int
	var role string
	
	err := s.db.QueryRow(checkQuery, invitationID, userID).Scan(&workspaceID, &inviterID, &role)
	if err != nil {
		return fmt.Errorf("invitation not found or insufficient permissions")
	}

	// Check if user can cancel (must be owner/admin or the person who sent the invite)
	if role != "owner" && role != "admin" && inviterID != userID {
		return fmt.Errorf("insufficient permissions to cancel invitation")
	}

	// Cancel the invitation
	cancelQuery := `
		UPDATE workspace_invitations 
		SET status = 'cancelled', updated_at = NOW()
		WHERE id = $1 AND status = 'pending'`
	
	result, err := s.db.Exec(cancelQuery, invitationID)
	if err != nil {
		return fmt.Errorf("failed to cancel invitation: %w", err)
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("failed to get rows affected: %w", err)
	}

	if rowsAffected == 0 {
		return fmt.Errorf("invitation not found or already processed")
	}

	return nil
}